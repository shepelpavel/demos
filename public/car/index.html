<!doctype html>
<html lang="en">
  <head>
    <title>Car tree.js</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div id="control_animation">
      <label>
        <input type="checkbox" />
        <span>Animation</span>
      </label>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "./three.module.min.js",
          "three/addons/": "./"
        }
      }
    </script>
    <script type="module">
      import * as THREE from './three.module.min.js'
      import { OrbitControls } from './controls/OrbitControls.js'
      import { GLTFLoader } from './loaders/GLTFLoader.js'
      import { RGBELoader } from './loaders/RGBELoader.js'
      import { Reflector } from './objects/Reflector.js'
      let renderer, scene, camera, controls
      const gltfLoader = new GLTFLoader()
      const rgbeLoader = new RGBELoader().setPath('textures/')
      const textureLoader = new THREE.TextureLoader().setPath('textures/')
      const controlAnimation = document.getElementById('control_animation')
      let animation = false
      const models = {}
      const floor = {}
      floor.obj = {}
      floor.textures = {}
      init().then(render)

      async function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFShadowMap
        document.body.appendChild(renderer.domElement)
        scene = new THREE.Scene()

        // camera
        camera = new THREE.PerspectiveCamera(
          10,
          window.innerWidth / window.innerHeight,
          1,
          500,
        )
        camera.position.set(20, 15, 20)

        // controls
        controls = new OrbitControls(camera, renderer.domElement)
        controls.minDistance = 16
        controls.maxDistance = 50
        controls.enablePan = false

        // direction light
        const dlPower = 10
        const dlHeight = 80
        const dlColor = 0xfff9e0
        const dlBias = -0.0001

        const dl1 = new THREE.DirectionalLight(dlColor, dlPower)
        dl1.position.set(300, dlHeight, 200)
        dl1.castShadow = true
        const dl2 = new THREE.DirectionalLight(dlColor, dlPower)
        dl2.position.set(-300, dlHeight, -150)
        dl2.castShadow = true
        scene.add(dl1)
        scene.add(dl2)

        // background
        const bckTexture = rgbeLoader.load('bck.hdr')
        bckTexture.mapping = THREE.EquirectangularReflectionMapping
        scene.background = bckTexture
        scene.environment = bckTexture

        // floor mirror
        floor.obj.mirror = new Reflector(new THREE.CircleGeometry(30, 12), {
          color: new THREE.Color(0x000000),
        })
        floor.obj.mirror.rotation.set(Math.PI / -2, 0, 0)
        floor.obj.mirror.position.set(0, -0.501, 0)
        scene.add(floor.obj.mirror)
        // floor ghost
        floor.textures.ghost = textureLoader.load('floor-ghost.png')
        floor.textures.ghost.wrapS = THREE.RepeatWrapping
        floor.textures.ghost.wrapT = THREE.RepeatWrapping
        floor.textures.ghost.repeat.x = 10
        floor.textures.ghost.repeat.y = 10
        const floorGhostGeometry = new THREE.CircleGeometry(30, 12)
        const floorGhostMaterial = new THREE.MeshBasicMaterial({
          map: floor.textures.ghost,
        })
        floorGhostMaterial.transparent = true
        floor.obj.ghost = new THREE.Mesh(floorGhostGeometry, floorGhostMaterial)
        floor.obj.ghost.rotation.set(Math.PI / -2, 0, 0)
        floor.obj.ghost.position.set(0, -0.5, 0)
        scene.add(floor.obj.ghost)

        // Model
        models.model_body = await gltfLoader.loadAsync('./models/body.glb')
        models.model_body.scene.rotation.set(0, Math.PI, 0)
        scene.add(models.model_body.scene)

        models.model_doorl = await gltfLoader.loadAsync('./models/doorl.glb')
        models.model_doorl.scene.rotation.set(0, Math.PI, 0)
        models.model_doorl.scene.position.set(0.77, 0, 0.725)
        scene.add(models.model_doorl.scene)

        models.model_doorr = await gltfLoader.loadAsync('./models/doorr.glb')
        models.model_doorr.scene.rotation.set(0, Math.PI, 0)
        models.model_doorr.scene.position.set(-0.77, 0, 0.725)
        scene.add(models.model_doorr.scene)

        models.model_wheel_fl = await gltfLoader.loadAsync('./models/wheel.glb')
        models.model_wheel_fl.scene.position.set(0.75, -0.16, 1.15)
        scene.add(models.model_wheel_fl.scene)

        models.model_wheel_fr = await gltfLoader.loadAsync('./models/wheel.glb')
        models.model_wheel_fr.scene.position.set(0.75, -0.16, -1.27)
        scene.add(models.model_wheel_fr.scene)

        models.model_wheel_bl = await gltfLoader.loadAsync('./models/wheel.glb')
        models.model_wheel_bl.scene.rotation.set(0, Math.PI, 0)
        models.model_wheel_bl.scene.position.set(-0.75, -0.16, 1.15)
        scene.add(models.model_wheel_bl.scene)

        models.model_wheel_br = await gltfLoader.loadAsync('./models/wheel.glb')
        models.model_wheel_br.scene.rotation.set(0, Math.PI, 0)
        models.model_wheel_br.scene.position.set(-0.75, -0.16, -1.27)
        scene.add(models.model_wheel_br.scene)

        // resize
        window.addEventListener('resize', onWindowResize)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
        render()
      }

      function render(time = 0) {
        time *= 0.001
        renderer.render(scene, camera)
        requestAnimationFrame(render)
        animate()
      }

      // animate
      function animate() {
        if (animation) {
          floor.textures.ghost.offset.set(
            floor.textures.ghost.offset.x,
            floor.textures.ghost.offset.y - 0.005,
          )
          models.model_wheel_fl.scene.rotation.set(
            models.model_wheel_fl.scene.rotation.x + 0.1,
            models.model_wheel_fl.scene.rotation.y,
            models.model_wheel_fl.scene.rotation.z,
          )
          models.model_wheel_fr.scene.rotation.set(
            models.model_wheel_fr.scene.rotation.x + 0.1,
            models.model_wheel_fr.scene.rotation.y,
            models.model_wheel_fr.scene.rotation.z,
          )
          models.model_wheel_bl.scene.rotation.set(
            models.model_wheel_bl.scene.rotation.x + 0.1,
            models.model_wheel_bl.scene.rotation.y,
            models.model_wheel_bl.scene.rotation.z,
          )
          models.model_wheel_br.scene.rotation.set(
            models.model_wheel_br.scene.rotation.x + 0.1,
            models.model_wheel_br.scene.rotation.y,
            models.model_wheel_br.scene.rotation.z,
          )
          if (models.model_doorl.scene.rotation.y > 2.5) {
            models.model_doorl.scene.rotation.set(
              models.model_doorl.scene.rotation.x,
              models.model_doorl.scene.rotation.y - 0.02,
              models.model_doorl.scene.rotation.z,
            )
          }
          if (models.model_doorr.scene.rotation.y < 3.78) {
            models.model_doorr.scene.rotation.set(
              models.model_doorr.scene.rotation.x,
              models.model_doorr.scene.rotation.y + 0.02,
              models.model_doorr.scene.rotation.z,
            )
          }
        } else {
          if (models.model_doorl.scene.rotation.y < Math.PI) {
            models.model_doorl.scene.rotation.set(
              models.model_doorl.scene.rotation.x,
              models.model_doorl.scene.rotation.y + 0.02,
              models.model_doorl.scene.rotation.z,
            )
          }
          if (models.model_doorr.scene.rotation.y > Math.PI) {
            models.model_doorr.scene.rotation.set(
              models.model_doorr.scene.rotation.x,
              models.model_doorr.scene.rotation.y - 0.02,
              models.model_doorr.scene.rotation.z,
            )
          }
        }
      }

      function switchAnimation(check = false) {
        if (check) {
          animation = true
        } else {
          animation = false
        }
      }

      controlAnimation.addEventListener('change', (event) => {
        switchAnimation(event.target.checked)
      })
    </script>
  </body>
</html>
